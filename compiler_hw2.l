/* Definition section */
%{
#include "compiler.h"
#include "y.tab.h"	/* header file generated by bison */

#define BUF_SIZE 256
extern YYSTYPE yylval; //YYSTYPE
char buf[BUF_SIZE];

int line_num = 0;
int comment_num = 0;
int comment_line = -1;
int error_flag[2] = {0};
char msg[10][100];
int error_num = 0;
int dump_flag = 0;
/* This macro is used to record code line */
#define CONCAT { strncat(buf, yytext, BUF_SIZE - strlen(buf) - 1); }
%}

/* Define regular expression label */
digit		[0-9]
letter		[a-zA-Z]
integer     {digit}+
float       {digit}+"."{digit}+
id			{letter}+({letter}|{digit})*

%option yylineno

%x COMMENT STRING_STATE

/* Rules section */
%%

 /* Arithmetic */
"+"     { CONCAT; return ADD; }
"-" 	{ CONCAT; return SUB; }
"*" 	{ CONCAT; return MUL; }
"/" 	{ CONCAT; return DIV; }
"%"     { CONCAT; return MOD; }
"++"    { CONCAT; return INC; }
"--"    { CONCAT; return DEC; }

 /* Relational */
">"		{ CONCAT; return MT; }
"<"		{ CONCAT; return LT; }
">="	{ CONCAT; return MTE; }
"<="	{ CONCAT; return LTE; }
"=="	{ CONCAT; return EQ; }
"!="	{ CONCAT; return NE; }

 /* Assignment */
"="		{ CONCAT; return ASGN; }
"+="	{ CONCAT; return ADDASGN; }
"-="	{ CONCAT; return SUBASGN; }
"*="	{ CONCAT; return MULASGN; }
"/="	{ CONCAT; return DIVASGN; }
"%="	{ CONCAT; return MODASGN; }

 /* Logical */
"&&"	{ CONCAT; return AND; }
"||"	{ CONCAT; return OR; }
"!"		{ CONCAT; return NOT; }

 /* Delimiters */
"("		{ CONCAT; return LB; }
")"		{ CONCAT; return RB; }
"{"		{ CONCAT; return LCB; }
"}"		{ CONCAT; return RCB; }
"["		{ CONCAT; return LSB; }
"]"		{ CONCAT; return RSB; }
","		{ CONCAT; return COMMA; }

 /* Print Keywords */	
"print"		{ CONCAT; return PRINT; }

 /* Condition and Loop Keywords */
"if"		{ CONCAT; return IF; }
"else"		{ CONCAT; return ELSE; }
"for"		{ CONCAT; return FOR; }
"while"		{ CONCAT; return WHILE; }

 /* Declaration Keywords */
"void"		{ CONCAT; yylval.type = "void";
                return VOID;
            }
"int"		{ CONCAT; yylval.type = "int";
                return INT;
            }
"float"  	{ CONCAT; yylval.type = "float";
                return FLOAT;
            }
"string"  	{ CONCAT; yylval.type = "string";
                return STRING;
            }
"bool"  	{ CONCAT; yylval.type = "bool";
                return BOOL;
            }

 /* boolean Keywords */
"true"      { CONCAT; yylval.value.b_val = 1;
                return TRUE;
            }
"false"     { CONCAT; yylval.value.b_val = 0;
                return FALSE;
            }

"return"    { CONCAT; return RET; }

 /* String Constant */
\"				        { CONCAT; BEGIN STRING_STATE;
                            return QUOTA;
                        }
<STRING_STATE>\"		{ CONCAT; BEGIN INITIAL; 
                            return QUOTA;
                        }
<STRING_STATE>[^"]*		{ CONCAT; yylval.value.string = strdup(yytext);
                            return STR_CONST;
                        }

 /* Number Constant */
{integer}	{ CONCAT; yylval.value.i_val = atoi(yytext);
                return I_CONST;
            }
{float}	    { CONCAT; yylval.value.f_val = atof(yytext);
                return F_CONST;
            }

 /* C type Comment */
"/*"				{ BEGIN COMMENT;
                        CONCAT;
                        if (line_num != comment_line) {
                            comment_num++;
                        }
                    }
<COMMENT>[^*\n]+	{ CONCAT; }
<COMMENT>\n			{ if(strcmp(buf, "\0") == 0)
                            printf("%d:\n", ++line_num);
                        else
                            printf("%d: %s\n", ++line_num, buf);
                        memset(buf, '\0', BUF_SIZE);
                        comment_num++;}
<COMMENT>"*"		{ CONCAT; }
<COMMENT>"*/"		{ BEGIN INITIAL;
                        CONCAT;
                        comment_line = line_num; }

 /* C++ type Comment */
\/\/.*	{ CONCAT; comment_num++; }

 /* Variable ID */
 {id}       { CONCAT; yylval.value.id_name = strdup(yytext);
                return ID;
            }

 /* others */

[;]         { CONCAT; return SEMICOLON; }
[\n]        {   if(strcmp(buf, "\0") == 0)
                    printf("%d:\n", ++line_num);
                else
                    printf("%d: %s\n", ++line_num, buf);
                    
                if(error_flag[1] == 1) {
                    for (int i = 0; i < error_num; i++) {
                        yyerror(msg[i]);
                    }
                    error_flag[1] = 0;
                    error_num = 0;
                }          
                if(error_flag[0] == 1) {
                    yyerror("syntax error");
                    yyterminate();
                }
                if(dump_flag == 1) {
                    dump_symbol();
                    dump_flag = 0;
                }
                memset(buf,'\0', BUF_SIZE);
                 }
[ \t]		{ CONCAT; } /* Ignore */
[^ \t\n] 	{ CONCAT; } /* Ignore other charactor sets */
<<EOF>>     { yyterminate(); }

%%

int yywrap()
{
    return 1;
}
